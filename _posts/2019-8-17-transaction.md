---
layout: post
title: 数据库的事务支持
category: system
tags: io
description: 事务这个词你也许已经听说过很多次了，甚至对它的ACDI特性都很了解，但是你知道它底层是如何保存的吗
---

## 事务的 ACDI 特性

首先我们先介绍一下事务的四个特性。原子性，保证事务的一组操作，要么全部执行，要么都不执行，这个其实是事务的主要特性。一致性，保证数据库中的数据，只会从一个一致性状态，转移到另一个一致性状态，这里的一致性指的是数据的中数据库的约束（非空，值唯一,数据格式）和数据库使用者的隐含数据约束（比如用户转账时金额总和不变）。隔离性，由于现代的数据库都是多个事务并发执行的，为了保证事务再并发执行下正确执行，就需要设置不同的隔离级别。持久性，数据库需要保证事务执行后，更改或新增的数据被保存到磁盘中，即使之后崩溃或断电，数据也不会丢失。事务最重要的两个特性是原子性和持久性，一致性其实大多情况下需要开发人员自己保证的，而隔离性其实是事务并发时的问题。本文也主要探究一下事务的原子性和持久性的保证。

## 如何不依赖日志实现

如果你对数据库的底层了解一点，那么就一定知道它是由日志来保证原子性的，那么为什么要使用日志，不使用日志可不可以呢？这些你都思考过了么？为了研究日志算法的细节，我们使用一种纪法来描述所有使数据在地址空间之间的移动的操作。我们使用的原语包括：

- INPUT(X): 将包含数据库元素 X 的磁盘块拷贝到主存缓冲区
- READ(X, t): 将数据库元素 X 拷贝到事务的局部变量 t。更准确的说，如果包含数据库元素 X 的块不在主存缓冲区中，则先执行 INPUT(X), 接着将 X 的值赋给临时变量 t。
- WRITE(X, t): 将局部变量 t 的值，拷贝到主存缓冲区的数据库元素 X。如果包含数据库元素 X 的块不在主存缓冲区中，则先执行 INPUT(X), 接着将 t 的值赋给缓冲区中的数据库元素 X.
- OUTPUT(X): 将包含数据库元素 X 的缓冲区中的块拷贝会磁盘。

首先，我们举一个非常常见的转账事务

```sql
READ(A, t)
t = t - 10
WRITE(A, t)
READ(B, t)
t = t + 10
READ(B, t)
OUTPUT(A)
OUTPUT(B)
```

现在假设我们事务执行的中间出现了故障，比如在 OUTPUT(A), 之前数据库突然崩溃了，会对我们磁盘里的数据有影响吗？没有，数据库里的数据完全没有被改变，还处于事务开始前的状态，而假设数据库在 OUTPUT(A), 之后崩溃，就会出现问题。因为此时磁盘中的数据，A 的钱减少了 10，而 B 的钱还是原来的数量，没有增加，这就出现了不一致。而假设 OUPUT(A), OUTPUT(B)者两个操作是一个原子操作，就是要么两个都写入成功，要么两个都写入失败。那么我们不就保证事务的原子性了吗？而这可能吗？当然是有可能的，传统的硬盘都是由一个个盘片组成的，每个盘片根据半径划分一个个磁道，磁道中根据角度划分为一个个扇区，而每次进行读写的最小单位也就是扇区。如果 A,B 两个的值在一个扇区中，那么 OUPUT(A), OUTPUT(B), 也就是一次 IO 写，那么要么成功，要么失败，不会存在中间状态。当然，这只是假设中的情况，我们不可能保证任意两条数据都在一个扇区中，所以注定我们一个事务中需要多个 IO 写，那么如何保证呢，我们可以在开始的时候先写入一个开始标志，在完成后写入一个结束标志。这样万一崩溃了，检测开始和结束标志，就知道是否出现了不一致，同时写入的时候同时记录一下原来的数据，出现不一致回退就可以了。这其实就是 undo 日志的思路。

## undo/redo 日志的实现过程

前面其实已经说了下日志的思路，下面来仔细讲一下 undo 日志的具体原理吗。我们可以讲日志看作一个只允许添加的一个文件，在事务的执行过程中，我们不断的讲日志记录追加到日志文件中。日志记录同样也有缓冲区块，日志记录首先会被加入缓冲区块中，然后再合适的时候写入到磁盘中.
首先，我们先说一些常用的日志记录形式。

- &lt;START T&gt;: 这一纪录表示事务 T 已开始
- &lt;ABORT T&gt;: 中止事务 T，这表示事务 T 之前的所有修改操作都要进行回滚，保持到事务开始前的状态
- &lt;COMMIT T&gt;: 事务 T 提交的记录。这表示一个事务已经完成，事务过程中对数据的修改都应该被保存到磁盘，不会因为崩溃或其他原因丢失。

### undo 日志

对于 undo 日志而言，我们唯一需要的其他日志类型是更新日志。更新日志是一个三元组&lt;T, X, v&gt;。这一记录的含义是：事务 T 改变了数据库元素 X,而 X 原来的值是 v。需要注意的是，我们的记录是在 OUPUT 操作之前，先写入日志文件中，这样如果事务中止，就可以使用日志记录来回滚。这也就是 undo 日志的规则，即：

- U1: 如果事务 T 改变了数据库元素 X, 那么形如<T, X, v>的日志记录必须在 X 的新值写入磁盘前（即 OUTPUT(X)）被写入磁盘（FLUSH LOG）
- U2: 如果事务 T 提交，则其 COMMIT 日志记录必须在事务改变的所有数据库元素先写到磁盘之后写到磁盘中, 只有 COMMIT 日志写入磁盘后，才认为事务成功。

规则 U1 我们刚才已经解释，而规则 U2 是因为，只有事务的所有操作都已写入磁盘，我们才认为事务完成，之后写入 COMMIT 日志，需要注意 COMMIT 日志同步到磁盘中之后，才认为事务成功，负责在崩溃时，因为磁盘中没有 COMMIT 日志，而将事务回滚。  
现在我们来按照 undo 日志来重新考虑刚才的日志。

| 步骤 | 动作        | t   | M-A | M-B | D-A | D-B | 日志              |
| ---- | ----------- | --- | --- | --- | --- | --- | ----------------- |
| 1)   |             |     |     |     |     |     | &lt;START T&gt;   |
| 2)   | READ(A, t)  | 100 | 100 |     | 100 | 100 |                   |
| 3)   | t = t - 10  | 90  | 100 |     | 100 | 100 |                   |
| 4)   | WRITE(A, t) | 90  | 90  |     | 100 | 100 | &lt;T, A, 100&gt; |
| 5)   | READ(B, t)  | 100 | 90  | 100 | 100 | 100 |                   |
| 6)   | t = t + 10  | 110 | 90  | 100 | 100 | 100 |                   |
| 7)   | WRITE(B, t) | 110 | 90  | 110 | 100 | 100 | &lt;T, B, 100&gt; |
| 8)   | FLUSH LOG   |     |     |     |     |     |                   |
| 9)   | OUTPUT(A)   | 110 | 90  | 110 | 90  | 100 |                   |
| 10)  | OUTPUT(B)   | 110 | 90  | 110 | 90  | 110 |                   |
| 11)  |             |     |     |     |     |     | &lt;COMMIT,T&gt;  |
| 12)  | FLUSH LOG   |     |     |     |     |     |                   |

好的，现在假设系统故障发生了，有可能一些事务当中一部分的更新已经到达了数据库，但是事务中另一部分更新尚未到达数据库，那么这个事务的执行就不是原子的,就比如在第 9）之后发生故障。恢复管理器必须使用日志来讲数据库恢复到某个一致的状态。首先我们需要查看日志记录中的日志，查看其中的日志记录，我们需要将其中记录的事务分为已提交事务和未提交事务。由于日志中可能存在多个未提交的事务，索引在在恢复的顺序必须从尾部开始扫描, 对于每一个&lt;T, X, v&gt;,如果之前有记录&lt;COMMIT T&gt;, 那么这个事务的所有更新都已经同步到磁盘，如果不存在，那么这个事务就可能修改没有全部同步到磁盘，需要进行恢复。对于未提交的事务，我们根据日志中记录的操作，将数据恢复到原来的状态。恢复完成后，为每个未完成的事务写入一个&lt;ABORT T&gt;，然后刷新日志，可以继续新的事务。

### redo 日志

undo 日志有一个问题，就是我们在将事务所改变的所有数据写到磁盘之前不能提交该事务，有时，如果让数据库修改暂时只存在主存中，我们可以节省磁盘 IO,提高数据库性能。那么我们应该怎么做呢，假设我们的事务已经提交了，但是事务中的数据修改并没有同步到磁盘中，这时假如发生了崩溃，我们必须将数据中的数据同步到事务提交后的状态。那么日志中应该记录什么内容呢？其实跟 undo 日志差不多，不过对于每一个修改操作，我们需要保存的并不是数据之前的值，而是修改之后的值。也即&lt;T, X, v&gt;的含义是“事务 T 为数据库元素 X 写入新值 v”。同时，对于 redo 日志，数据和日志到达磁盘的顺序可以用一条“redo 规则”描述，即

- 在修改磁盘上的任何数据元素 X 以前，要保证 X 的这一修改相关的所有日志记录，包括修改记录&lt;T， X，v>及<COMMIT, T>记录都要被写入磁盘上。

让我们重新考虑下之前的事务，在使用 redo 日志情况下会是什么情况。

| 步骤 | 动作        | t   | M-A | M-B | D-A | D-B | 日志              |
| ---- | ----------- | --- | --- | --- | --- | --- | ----------------- |
| 1)   |             |     |     |     |     |     | &lt;START T&gt;   |
| 2)   | READ(A, t)  | 100 | 100 |     | 100 | 100 |                   |
| 3)   | t = t - 10  | 90  | 100 |     | 100 | 100 |                   |
| 4)   | WRITE(A, t) | 90  | 90  |     | 100 | 100 | &lt;T, A, 90&gt;  |
| 5)   | READ(B, t)  | 100 | 90  | 100 | 100 | 100 |                   |
| 6)   | t = t + 10  | 110 | 90  | 100 | 100 | 100 |                   |
| 7)   | WRITE(B, t) | 110 | 90  | 110 | 100 | 100 | &lt;T, B, 110&gt; |
| 8)   |             |     |     |     |     |     | &lt;COMMIT,T&gt;  |
| 9)   | FLUSH LOG   |     |     |     |     |     |                   |
| 10)  | OUTPUT(A)   | 110 | 90  | 110 | 90  | 100 |                   |
| 11)  | OUTPUT(B)   | 110 | 90  | 110 | 90  | 110 |                   |

观察事务记录我们可以发现，记录的值变为了修改之后的值，同时我们发现&lt;COMMIT, T&gt;发生在 OUTPUT 动作之前，同时减少了 FLUSH LOG 操作，此外，当中 10), 11)的两个 OUTPUT 动作并不是必须的，可以由数据库管理在合适的时候同步到磁盘，这样可以合并一些同步操作，提高性能。
那么当数据库崩溃时，如何使用 redo 日志来恢复呢。同 undo 日志不同，因为我们是重做事务的操作，索引是从头扫描日志，首先，我们需要确定已提交的事务。之后从首部扫描日志，对每个&lt;T, X, v&gt;，如果 T 是已提交事务，就重新将 X 的值 v 同步到磁盘，否则什么也不做，最后对每个未完成的事务写入一个&lt;ABORT T&gt;，刷新日志，之后就可以开始新的事务。  
这样，我们可以发现，redo 日志的思路是，我先将修改后的数据保存到日志中，同时事务提交的时候 FLUSH Log，这样就可以保证事务的修改数据被保存到磁盘中了，之后计算数据元素写入磁盘中发生故障，那么我也可以使用 redo 日志中记录的日志来恢复事务。  
除了普通的 redo 日志和 undo 日志，其实还有 undo/redo 日志，就是对于每一个修改操作同时记录原来的值和修改后的值，不过这种日志只是结合增加了日志和数据写入磁盘顺序的灵活性，在此不再介绍。

## MySQL中的日志类型

既然已经了解了undo日志和redo日志，你是否疑惑在MySQL是如何是使用日志来保证事务的。其实在MySQL中一共存在两种日志，一种是binlog，主要用来恢复和复制，一种是引擎自身的日志，主要用来保证事务。如InnoDB的redo和undo日志，这里我们主要讲一下InndoDB的redo和undo日志。刚才已经讲到，redo日志由于更少的磁盘同步次数，性能方面更好，所以一般的数据库中都会使用redo日志来保障事务的持久性。不过一般事务中还经常需要进行回滚操作，如果每次回滚的时候，都全部重做恢复到之前的状态，那就太傻了，所以有了undo日志的出现，同时，还可以使用undo日志来实现mvcc。这时，你可能会想，为什么不使用undo/redo日志呢，这样只需要一个日志可以了，首先这样会大大增加日志文件的大小，同时降低性能。其次，在很多情况下一个事务提交以后，我们就不需要它的undo日志了，这时候就可以将其页分配给其他事务使用，提高性能。
