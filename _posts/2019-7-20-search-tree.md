---
layout: post
title: 从二叉树到B-树，B+树
category: data-structure
tags: 数据结构
description: 搜索树
---

## 搜索树

一般在面试中经常谈论到的二叉树，并不是普通的二叉树，更准确的应该叫做二叉搜索树，而经常与其作比较的 B-树和 B+树是多路搜索树。它们都属于搜索树。搜索树其实就是一种基于二分查找来进行快速搜索的数据结构，为了满足此性质，树中每一个节点中每个 key 要大于左边的子树中的每个 key，小于右边子树中的每个 key。这样我们就可以利用二分查找来进行搜索了。其实二叉搜索树和 B 树 B+树的搜索时间复杂度都是相同级别的，可能会根据不同的算法（平衡性不同）而有所差异，不过最大不同在于 B 树和 B+树一个节点中可以有多个 key，更加适合文件系统这种读写代价大的情景下。

## 二叉搜索树

二叉搜索树一般最常见的有两种，一种是平衡二叉树，一种是红黑树。平衡二叉树的平衡性更好，也因此使得插入删除时进行的平衡性调节相比红黑树更频繁也更耗费性能。红黑树只实现大致的平衡，在综合表现中，要比平衡二叉树要更好，因此一般红黑树在实际中应用的更多一些。  
下面来看一下平衡二叉树的定义：

- 它是一颗空树或者他的两个子树的高度差绝对值不超过 1
- 它的左右两个子树都是一个平衡二叉树。

好，假设现在，我们有一个平衡二叉树如下(顺序插入 1-9 构建):
![](/images/binaery-tree.png)

我们向其中插入一个 10, 插入过程如下。
![](/images/binaery-tree.gif)
可以看到，插入后不满足平很二叉树的定义了，之后开始调整，重新变成一个平衡二叉树。

之后我们再来看一下红黑树,红黑树的每一个节点都有一个颜色标记，并且有以下要求；

- 节点是红色或者黑色
- 根节点是黑色
- 从每个叶子结点到根节点的路径上不能有两个连续的红节点
- 从任一节点到每个叶子节点的路径上包含相同的黑节点

从最后一点性质看，红黑树只保证了书中黑节点是据对平衡的，同时其他的性质又保证了红节点的数量不能超过树种总结点数量的一般以上，这样最坏的时间复杂度也在$O(2\log(n))$。
同样我们构建一颗红黑树如下
![](/images/red-black-tree.png)
之后插入一个节点
![](/images/red-black-tree.gif)
可以发现，插入后仅仅进行了颜色调整，并没有进行结构上的调整，仍然满足红黑树的要求，从这里和平衡二叉树比较我们可以看出红黑树在插入上的优势。

## B-树

B-树又叫 Balance 树, 不像二叉树，B 树的每个节点关键字数量是不一定的，一个 m 阶 B 树是一颗 m 路搜索树，它或者是空树，或者是满足下列性质的树：

- 根节点至少有两个子节点
- 每个非根节点所包含的关键字数量 j 满足： $\llcorner m/2 \lrcorner -1 <= j <= m-1$
- 除根节点之外的所有节点（不包括叶子节点）的度数正好是关键字总数加 1，故内部子树个数 k 满足： $\llcorner m/2 \lrcorner <= k <= m$
- 所有的叶子节点都位于同一层

构建一颗 4 阶 B-树如下：
![](/images/b-tree.png)  
向 B-树中插入一个节点：
![](/images/b-tree.gif)

## B+树

B+树是 B 树的一种变体，和 B-树不同的地方在于，所有的数据都储存在叶子节点，非叶子节点只保存关键字。同时叶子节点之间使用指针连接起来，这样可以方便的进行遍历和范围查找。

构建一颗 4 阶 B+树如下：
![](/images/b+tree.png)
向其中插入一个节点。
![](/images/b+tree.gif)
看到这里你可能会疑问，B+树相比 B-树高度好像高度更高了，似乎查找需要耗费的代价增大了，除了范围查找外，似乎也没什么其他的优点了，别急，往下看。

## 为什么数据库索引一般使用 B+树

上面已经介绍了平衡二叉树，红黑树，B-树和 B+树，那么为什么数据库索引偏偏要使用 B+树呢。首先先，这里我们谈论的数据库指的是 Mysql 一类的传统关系性数据库，它需要将数据保存到硬盘上。那么就必须要考虑到硬盘的特点，一般的机械硬盘，其读写是以扇区为基本单位的。通常是 4KB(8 个扇区)。这样的话，我们希望尽量减少 IO 的读取，那么就希望一个节点中储存尽量多关键字，所以一般使用多路搜索树。而对于 B-树和 B+树，由于 B+树的非叶子节点中仅包含关键字，所以每一个节点可以包含更多的关键字，因此此一般使用 B+树。举个例子，夸张一点，假设一个记录的大小是 1KB， 那么我们一个节点仅能储存 4 个记录，假设 3 层的话并且每个节点存满也仅能保存 124 条记录，而如果是 B+树呢，一般使用 int 作为 id, 4 个字节, 我们加上指针等一些其他的数据，假设每个节点可以保存 100 个数据，叶子节点是仍然保存 4 个记录，那么 3 层全部存满的话可以 大约可以保存 4 万条记录，并且仅通过 3 次 IO 就可以找到。这样就可以很明显的看出，为什么要使用 B+树来建立索引了。

---

### 数据结构可视化网站

[数据结构可视化](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

### 参考内容

[B+数在磁盘中的应用](https://www.cnblogs.com/nullzx/p/8978177.html)
