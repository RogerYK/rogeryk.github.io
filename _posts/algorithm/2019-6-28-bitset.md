---
layout: post
title: 使用bitset解决加减多项式最优解问题
category: algorithm
tags: bitset
description: 使用bitset来方便的解决加减多项式的最优解。
---

## 问题

最近做leetcode的竞赛，发现下面一道题。

> 有一堆石头，每块石头的重量都是正整数。
>
> 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
>
> 如果 x == y，那么两块石头都会被完全粉碎；
> 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
> 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。
>
>  
>
> 示例：
>
> 输入：[2,7,4,1,8,1]
> 输出：1
> 解释：
> 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
> 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
> 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
> 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
>  
>
> 提示：
>
> 1 <= stones.length <= 30
> 1 <= stones[i] <= 1000
>

## 思路

讲一下思路，比如有个数组[a,b,c]，我们每次选出两个数字，a, b; 得到a-b，然后再将新数字放入(0忽略)。之后再选出两个数字, c，和，a-b, 得到c+b-a。最后的到的结果实际上是对数组中的每个数字进行加减运算得到的, 其实就是一个加减多项式的最优解问题。一共结果有2^(n-1)种，我们求出其中结果最好的就行了。不过数据太大，直接枚举肯定不行, 不过可以使用bitset来做。

## 代码

```c++
#include <bitset>
using namespace std;

const int bound = 40000;
const int capacity = 80000;

class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {

        bitset<80000> F;
        F.reset();
        F[bound] = 1;

        for (int stone : stones) {
            F = (F << stone) | (F >> stone);
        }
        for (int i = 0; i < 30000; i++) {
            if (F[bound+i]) return i;
        }
        return -1;
    }
};
```

## 讲解

是不是非常简单，我们一开始推断数据范围，然后定义了一个bitset, 我们选取中间位置为0，想做向右分别代表一个数字。F一开始设为0，然后不断读取数字，对原来的F进行左移和右移个单位，表示对原来的结果进行加减相关个单位。这样我们就只用一次遍历就得到了所有的结果，之后就是从0开始找一个最小值。